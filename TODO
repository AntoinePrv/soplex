$Id: TODO,v 1.80 2006/01/31 19:29:42 bzforlow Exp $

- Wieso ist das SPxLP protected from LPColSet und LPRowSet abgeleitet und
  spiegelt dann mehrere von deren Methoden, um sie wieder public zugreifbar zu
  machen? Betrifft lower(), upper(), usw.

- factor.cpp: "??? mkwtz originally was long, maybe to avoid an overflow in this instruction?"
   -> später auf long ändern

- diverse "#ifdef USE_OLD"-Stellen rauswerfen

- Es wird infeasible/unbounded gemeldet je nach dem welcher algo 
  gerade am Laufen war.

- der col_first parameter bei scale wird nicht mehr benutzt.

Vermutlich sind die meisten solve() methoden in 
CLUFactor::solve.cpp const. Müßten von den Pointern
befreit werden

SSVector::multAdd() sollte von den pointern befreit werden.

simplifier sollten nicht unsimplify machen, sondern
uncrush_x und uncrush_pi, das LP kann man sich auch merken.

neos4, neos5 werden fälschlicherweise als infeasible gemeldet.

Diesen Kram mal als @todo's schreiben ;-)

Genau gucken, was spxredundantsm eigendlich macht. Das scheint mir
mehr ein bound strengthening zu sein.
Ich habe nicht den eindruck, das der doppelte Zeilen/Spalten finden
würde.

Einzel remove so implementieren, dass alles weitergeschoben wird.


Es gibt Probleme, wenn der Preprocessor das Problem komplett erledigt.
Denn die Rueckgabe ist dann nicht UNBOUNDED/INFEASIBLE, sondern fertig.

isConsistent sollte eigentlich virtuell sein.

Memberfunctionen .has -> bool

Abbruch bei minimieren mit Upper Bound

primal: >= UB und optimal
dual  : >= UB und shift = 0

---------------

spxbasis  load(xxx) umbennen in loadDesc, loadLP usw.

-----------------------------------------------------------------------------

bin/soplex.linux.x86.gnu.dbg-ld  -e -r check/LP/netlib/etamacro.mps

soplex.linux.x86.gnu.dbg-ld: src/spxvecs.cpp:240: void soplex::SoPlex::computeFrhs2(const soplex::Vector &, const soplex::Vector &): Assertion `colfb[i] == coufb[i]' failed.

240                 assert(colfb[i] == coufb[i]);
Current language:  auto; currently c++
(gdb) print i
$1 = 368
(gdb) print colfb[i]
$2 = 0
(gdb) print coufb[i]
$3 = -nan(0xc000000000000000)

kommt auch bei check.netlib.linux.x86.gnu.dbg

-----------------------------------------------------------------------------

nug12

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 41.26    400.98   400.98 41390449     0.01     0.01  soplex::CLUFactor::updateRow(int, int, int, int, double, double)
 10.33    501.40   100.42    45964     2.18     2.18  soplex::CLUFactor::vSolveLright2(double *, int *, int *, double, double *, int *, int

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 34.29   4791.24  4791.24 634306343     0.00     0.00  soplex::CLUFactor::updateRow(int, int, int, int, double, double)
 11.91   6455.54  1664.30   709664     0.00     0.00  soplex::CLUFactor::vSolveLright2(double *, int *, int *, double, double *, int *, int

-----------------------------------------------------------------------------


stdio.h/printf die letzten erlegen.

tester/simplifier usw. auch wie pricer mit namen versehen.

neue abstracte basisklasse spxscaler mit spxequilim=spxscale
als erste implementierung.
   DataArray < Real > colscale;  ///< column scaling factors
   DataArray < Real > rowscale;  ///< row scaling factors
kann in die basisklasse
Als unterscheid zu simplifier kommt noch ein
getObjValue(col) aufruf dazu, außerdem kann dann der scaler
gleichseitig mit dem simplifiern eingesetzt werden.

vsolve/solve/update isNotZero() benutzen

openMP insbesondere pricer/ratiotest (compaq,intel)
ewtl die enterX/leaveX funktionen inlinen.

cplexrun mit delta = 1e-9 für bessere werte in check.

SVSet::memPack, vermutlichen bug in flexelint melden. this-> ist überflüssig.

BUG in spxscalesm.cc value() wird nicht descaliert. 
Entsprechender Aufruf fehlt auch in spxgeneralsm.cc

reinterpret_cast durchsehen

// lprow.cpp:double LPRow::infinity = 1e+100;
// spxlp.cpp:const double SPxLP::infinity = 1e+100;

Dokumentation: (alle * sind bereits fertig)

cring.h
clufactor.h
+slufactor.h  // hier fehlen noch ein paar Sachen  -> Thorsten!
+soplex.h // in Arbeit ;-)

sunos.sparc.sun LC 0 2494 14255
greenbea ER 
greenbeb ER

linux.alpha.compaq LC 0 542 3142
greenbea ER   =infeasible=
greenbeb LR   =infeasible=

linux.alpha.gnu LC 0 569 3399
greenbea LR
pilot-ja LR

osf1.alpha.compaq LC 0 522 2819
greenbeb ER
pilot    LR *
pilot87  ER

osf1.alpha.gnu LC 0 546 3286
greenbea LR 
pilot-ja LR

linux.x86.gnu LC 0 593 3209
greenbea ER 

hp-ux.hppa.hp LC 0 755 4626
greenbea LR
pilot-ja LR

irix.mips.sgi LC 0 6223 35624
greenbea LR
pilot-ja LR

linux.x86.intel LC 0 936 5121
greenbea ER







