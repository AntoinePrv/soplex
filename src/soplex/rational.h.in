
/* ----------------------------------------------------------------------
 * This file is autogenerated from the file multiprecision.hpp.in during
 * the cmake configuration of your project. If you need to make changes
 * edit the original file.
 * ----------------------------------------------------------------------
 */
#ifndef __SOPLEX_MULTIPRECISION_HPP_
#define __SOPLEX_MULTIPRECISION_HPP_
#define SOPLEX_DEBUG
#include <numeric>
#include <vector>
#include <string>

#include "soplex/spxdefines.h"
using namespace soplex;
#if @SOPLEX_HAVE_BOOST@
   #include <boost/multiprecision/number.hpp>

   #if @SOPLEX_HAVE_GMP@
   #include <boost/multiprecision/gmp.hpp>
   using namespace boost::multiprecision;
   using Rational = number<gmp_rational, et_off>;
   using Integer = mpz_int;
   inline void SpxLcm(Integer& result, Integer a, Integer b)
   {
      mpz_lcm(result.backend().data(), a.backend().data(), b.backend().data());
   }
   inline void SpxGcd(Integer& result, Integer a, Integer b)
   {
      mpz_gcd(result.backend().data(), a.backend().data(), b.backend().data());
   }
   #else
   #include <boost/multiprecision/cpp_int.hpp>
   #include <boost/multiprecision/detail/default_ops.hpp>
   using namespace boost::multiprecision;
   using Rational = cpp_rational;
   using Integer = cpp_int;
   inline void SpxLcm(Integer& result, Integer a, Integer b)
   {
      result = boost::multiprecision::lcm(a, b);
   }
   inline void SpxGcd(Integer& result, Integer a, Integer b)
   {
      result = boost::multiprecision::gcd(a, b);
   }
   #endif
   inline void printRational(Rational r)
   {
      std::cout << r << std::endl;
   }

   inline void printInteger(Integer r)
   {
      std::cout << r << std::endl;
   }
   inline bool isAdjacentTo(const Rational& r, const double& d)
   {
      double x = (double) r;
      double a;
      double b;
      Rational tmp = x;

      // the rational value is representable in double precision
      if( tmp == r)
         return true;
      // the rounded value is smaller than the rational value
      else if(tmp < r)
      {
         a = x;
         b = (double)nextafter(a, 1e100);
      }
      // the rounded value is larger than the rational value
      else
      {
         b = x;
         a = (double)nextafter(b, -1e100);
      }

      return ((a == d) || (b == d));
   }

   inline void invert(Rational& r)
   {
      r = Rational(denominator(r), numerator(r));
   }

   /// round up to next power of two
   inline void powRound(Rational& r)
   {
      Integer roundval;
      Integer den;
      Integer num;

      MSG_DEBUG(std::cout << "rounding " <<str(r) <<
               " to power of two" << "\n");

      num = numerator(r);
      den = denominator(r);
      roundval = num / den;

      MSG_DEBUG(std::cout << "   --> " <<str(roundval) << "\n");

      size_t binlog = roundval == 0 ? 1 : msb(roundval) + 1;
      Integer base = 2;

      MSG_DEBUG(std::cout << "   --> 2^" << binlog << "\n");

      roundval = boost::multiprecision::pow(base, binlog);

      MSG_DEBUG(std::cout << "   --> " <<str(roundval) << "\n");

      r = roundval;

      MSG_DEBUG(std::cout << "   --> " <<str(r) << "\n");
   }

   /// Size in specified base (bit size for base 2)
   inline int sizeInBase(const Rational R, const int base)
   {
      assert(base == 2);

      size_t densize = msb(denominator(R)) + 1;
      size_t numsize = msb(numerator(R)) + 1;

      return densize + numsize;
   }
   /// Total size of rational vector.
   inline int totalSizeRational(const Rational* vector, const int length, const int base)
   {
      assert(vector != 0);
      assert(length >= 0);
      assert(base >= 0);

      int size = 0;

      for(int i = 0; i < length; i++)
         size += sizeInBase(vector[i], base);

      return size;
   }

   /// Size of least common multiple of denominators in rational vector.
   inline int dlcmSizeRational(const Rational* vector, const int length, const int base)
   {
      assert(vector != 0);
      assert(length >= 0);
      assert(base == 2);

      Integer lcm;

      for(int i = 0; i < length; i++)
         SpxLcm(lcm, lcm, denominator(vector[i]));

      int size = msb(lcm) + 1;

      return size;
   }

   /// Size of largest denominator in rational vector.
   inline int dmaxSizeRational(const Rational* vector, const int length, const int base)
   {
      assert(vector != 0);
      assert(length >= 0);
      assert(base == 2);

      size_t dmax = 0;

      for(int i = 0; i < length; i++)
      {
         size_t dsize = msb(denominator(vector[i])) + 1;

         if(dsize > dmax)
            dmax = dsize;
      }

      return (int)dmax;
   }

   /* find substring, ignore case */
   static
   std::string::const_iterator findSubStringIC(const std::string & substr, const std::string & str)
   {
      auto it = std::search(
         str.begin(), str.end(),
         substr.begin(),   substr.end(),
         [](char ch1, char ch2) { return std::toupper(ch1) == std::toupper(ch2); }
      );
      return it;
   }

   inline Rational ratFromString(const char* desc)
   {
      Rational res;
      if( 0 == strcmp(desc, "inf") )
      {
         res = 1e100;
      }
      else if ( 0 == strcmp(desc, "-inf") )
      {
         res = -1e100;
      }
      else
      {
         std::string s(desc);
         /* case 1: string is given in nom/den format */
         if( s.find('.') == std::string::npos )
            res = Rational(desc);
         /* case 2: string is given as base-10 decimal number */
         else
         {
            std::string::const_iterator it = findSubStringIC("e", s);
            int mult = 0;
            if( it != s.end() )
            {
               int exponentidx = it - s.begin();
               mult = std::stoi(s.substr(exponentidx + 1, s.length()));
               s = s.substr(0, exponentidx);
            }
            // std::cout << s << std::endl;
            if( s[0] == '.' )
               s.insert(0, "0");
            size_t pos = s.find('.');
            size_t exp = s.length() - 1 - pos;
            std::string den("1");
            for( size_t i = 0; i < exp; ++i )
               den.append("0");

            s.erase(pos, 1);
            assert(std::all_of(s.begin()+1, s.end(), ::isdigit));
            // remove padding 0s
            if(s[0] == '-')
               s.erase(1, std::min(s.substr(1).find_first_not_of('0'), s.size()-1));
            else
               s.erase(0, std::min(s.find_first_not_of('0'), s.size()-1));

            s.append("/");
            s.append(den);
            res = Rational(s);
            res *= pow(10, mult);
         }
      }
      return res;
   }
#else
   using Rational = double;
   using Integer = int;
   //using Integer = int;
   // class Rational {
   //    public:
   //    double val;

   //    Rational(){};

   //    Rational(Integer a, Integer b)
   //    {
   //       this->val = a/b;  
   //    }

   //    /// assignment operator
   //    Rational& operator=(const Rational& r)
   //    {
   //       this->val = r.val;
   //       return *this;
   //    }

   //    /// assignment operator from long double
   //    Rational& operator=(const long double& r)
   //    {
   //       this->val = r;
   //       return *this;
   //    }

   //    /// assignment operator from double
   //    Rational& operator=(const double& r)
   //    {
   //       this->val = r;
   //       return *this;
   //    }

   //    /// assignment operator from int
   //    Rational& operator=(const int& i)
   //    {
   //       this->val = i;
   //       return *this;
   //    }

   //    /// typecasts Rational to double (allows only explicit typecast)
   //    operator double() const
   //    {
   //       return (double)this->val;
   //    }

   //    /// typecasts Rational to long double (allows only explicit typecast)
   //    operator long double() const
   //    {
   //       return this->val;
   //    }

   //    operator int() const
   //    {
   //       return (int)this->val;
   //    }

   //    /// equality operator
   //    friend bool operator==(const Rational& r, const Rational& s)
   //    {
   //       return (r.val == s.val);
   //    }

   //    /// inequality operator
   //    friend bool operator!=(const Rational& r, const Rational& s)
   //    {
   //       return (r.val != s.val);
   //    }

   //    /// less than operator
   //    friend bool operator<(const Rational& r, const Rational& s)
   //    {
   //       return (r.val < s.val);
   //    }

   //    /// less than or equal to operator
   //    friend bool operator<=(const Rational& r, const Rational& s)
   //    {
   //       return (r.val <= s.val);
   //    }

   //    /// greater than operator
   //    friend bool operator>(const Rational& r, const Rational& s)
   //    {
   //       return (r.val > s.val);
   //    }

   //    /// greater than or equal to operator
   //    friend bool operator>=(const Rational& r, const Rational& s)
   //    {
   //       return (r.val >= s.val);
   //    }

   //    /// equality operator for Rational and double
   //    friend bool operator==(const Rational& r, const double& s)
   //    {
   //       return (r.val > s - DEFAULT_EPS_ZERO)
   //             && (r.val < s + DEFAULT_EPS_ZERO);
   //    }

   //    /// inequality operator for Rational and double
   //    friend bool operator!=(const Rational& r, const double& s)
   //    {
   //       return (r.val <= s - DEFAULT_EPS_ZERO)
   //             || (r.val >= s + DEFAULT_EPS_ZERO);
   //    }

   //    /// less than operator for Rational and double
   //    friend bool operator<(const Rational& r, const double& s)
   //    {
   //       return (r.val < s);
   //    }

   //    /// less than or equal to operator for Rational and double
   //    friend bool operator<=(const Rational& r, const double& s)
   //    {
   //       return (r.val <= s);
   //    }

   //    /// greater than operator for Rational and double
   //    friend bool operator>(const Rational& r, const double& s)
   //    {
   //       return (r.val > s);
   //    }

   //    /// greater than or equal to operator for Rational and double
   //    friend bool operator>=(const Rational& r, const double& s)
   //    {
   //       return (r.val >= s);
   //    }

   //    /// equality operator for double and Rational
   //    friend bool operator==(const double& r, const Rational& s)
   //    {
   //       return (s.val > r - DEFAULT_EPS_ZERO)
   //             && (s.val < r + DEFAULT_EPS_ZERO);
   //    }

   //    /// inequality operator double and Rational
   //    friend bool operator!=(const double& r, const Rational& s)
   //    {
   //       return (s.val <= r - DEFAULT_EPS_ZERO)
   //             || (s.val >= r + DEFAULT_EPS_ZERO);
   //    }

   //    /// less than operator double and Rational
   //    friend bool operator<(const double& r, const Rational& s)
   //    {
   //       return (r < s.val);
   //    }

   //    /// less than or equal to operator double and Rational
   //    friend bool operator<=(const double& r, const Rational& s)
   //    {
   //       return (r <= s.val);
   //    }

   //    /// greater than operator double and Rational
   //    friend bool operator>(const double& r, const Rational& s)
   //    {
   //       return (r > s.val);
   //    }

   //    /// greater than or equal to operator double and Rational
   //    friend bool operator>=(const double& r, const Rational& s)
   //    {
   //       return (r >= s.val);
   //    }


   //    /// equality operator for Rational and long double
   //    friend bool operator==(const Rational& r, const long double& s)
   //    {
   //       return (r.val > s - DEFAULT_EPS_ZERO)
   //             && (r.val < s + DEFAULT_EPS_ZERO);
   //    }

   //    /// inequality operator for Rational and long double
   //    friend bool operator!=(const Rational& r, const long double& s)
   //    {
   //       return (r.val <= s - DEFAULT_EPS_ZERO)
   //             || (r.val >= s + DEFAULT_EPS_ZERO);
   //    }

   //    /// less than operator for Rational and long double
   //    friend bool operator<(const Rational& r, const long double& s)
   //    {
   //       return (r.val < s);
   //    }

   //    /// less than or equal to operator for Rational and long double
   //    friend bool operator<=(const Rational& r, const long double& s)
   //    {
   //       return (r.val <= s);
   //    }

   //    /// greater than operator for Rational and long double
   //    friend bool operator>(const Rational& r, const long double& s)
   //    {
   //       return (r.val > s);
   //    }

   //    /// greater than or equal to operator for Rational and long double
   //    friend bool operator>=(const Rational& r, const long double& s)
   //    {
   //       return (r.val >= s);
   //    }

   //    /// equality operator for long double and Rational
   //    friend bool operator==(const long double& r, const Rational& s)
   //    {
   //       return (s.val > r - DEFAULT_EPS_ZERO)
   //             && (s.val < r + DEFAULT_EPS_ZERO);
   //    }

   //    /// inequality operator long double and Rational
   //    friend bool operator!=(const long double& r, const Rational& s)
   //    {
   //       return (s.val <= r - DEFAULT_EPS_ZERO)
   //             || (s.val >= r + DEFAULT_EPS_ZERO);
   //    }

   //    /// less than operator long double and Rational
   //    friend bool operator<(const long double& r, const Rational& s)
   //    {
   //       return (r < s.val);
   //    }

   //    /// less than or equal to operator long double and Rational
   //    friend bool operator<=(const long double& r, const Rational& s)
   //    {
   //       return (r <= s.val);
   //    }

   //    /// greater than operator long double and Rational
   //    friend bool operator>(const long double& r, const Rational& s)
   //    {
   //       return (r > s.val);
   //    }

   //    /// greater than or equal to operator long double and Rational
   //    friend bool operator>=(const long double& r, const Rational& s)
   //    {
   //       return (r >= s.val);
   //    }

   //    /// equality operator for Rational and int
   //    friend bool operator==(const Rational& r, const int& s)
   //    {
   //       return r.val == s;
   //    }

   //    /// inequality operator for Rational and int
   //    friend bool operator!=(const Rational& r, const int& s)
   //    {
   //       return r.val != s;
   //    }

   //    /// less than operator for Rational and int
   //    friend bool operator<(const Rational& r, const int& s)
   //    {
   //       return r.val < s;
   //    }

   //    /// less than or equal to operator for Rational and int
   //    friend bool operator<=(const Rational& r, const int& s)
   //    {
   //       return r.val <= s;
   //    }

   //    /// greater than operator for Rational and int
   //    friend bool operator>(const Rational& r, const int& s)
   //    {
   //       return r.val > s;
   //    }

   //    /// greater than or equal to operator for Rational and int
   //    friend bool operator>=(const Rational& r, const int& s)
   //    {
   //       return r.val >= s;
   //    }

   //    /// equality operator for int and Rational
   //    friend bool operator==(const int& r, const Rational& s)
   //    {
   //       return r == s.val;
   //    }

   //    /// inequality operator for int and Rational
   //    friend bool operator!=(const int& r, const Rational& s)
   //    {
   //       return r != s.val;
   //    }

   //    /// less than operator for int and Rational
   //    friend bool operator<(const int& r, const Rational& s)
   //    {
   //       return r < s.val;
   //    }

   //    /// less than or equal to operator for int and Rational
   //    friend bool operator<=(const int& r, const Rational& s)
   //    {
   //       return r <= s.val;
   //    }

   //    /// greater than operator for int and Rational
   //    friend bool operator>(const int& r, const Rational& s)
   //    {
   //       return r > s.val;
   //    }

   //    /// greater than or equal to operator for int and Rational
   //    friend bool operator>=(const int& r, const Rational& s)
   //    {
   //       return r >= s.val;
   //    }

   //    /// addition operator
   //    Rational operator+(const Rational& r) const
   //    {
   //       Rational retval = *this;
   //       retval.val += r.val;
   //       return retval;
   //    }

   //    /// addition assignment operator
   //    Rational& operator+=(const Rational& r)
   //    {
   //       this->val += r.val;
   //       return *this;
   //    }

   //    /// addition operator for doubles
   //    Rational operator+(const double& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val += d;
   //       return retval;
   //    }

   //    /// addition assignment operator for doubles
   //    Rational& operator+=(const double& d)
   //    {
   //       this->val += d;
   //       return *this;
   //    }

   //    /// addition operator for ints
   //    Rational operator+(const int& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val += d;
   //       return retval;
   //    }

   //    /// addition assignment operator for ints
   //    Rational& operator+=(const int& d)
   //    {
   //       this->val += d;
   //       return *this;
   //    }

   //    /// subtraction operator
   //    Rational operator-(const Rational& r) const
   //    {
   //       Rational retval = *this;
   //       retval.val -= r.val;
   //       return retval;
   //    }

   //    /// subtraction assignment operator
   //    Rational& operator-=(const Rational& r)
   //    {
   //       this->val -= r.val;
   //       return *this;
   //    }

   //    /// subtraction operator for doubles
   //    Rational operator-(const double& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val -= d;
   //       return retval;
   //    }

   //    /// subtraction assignment operator for doubles
   //    Rational& operator-=(const double& d)
   //    {
   //       this->val -= d;
   //       return *this;
   //    }

   //    /// subtraction operator for ints
   //    Rational operator-(const int& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val -= d;
   //       return retval;
   //    }

   //    /// subtraction assignment operator for ints
   //    Rational& operator-=(const int& d)
   //    {
   //       this->val -= d;
   //       return *this;
   //    }

   //    /// multiplication operator
   //    Rational operator*(const Rational& r) const
   //    {
   //       Rational retval = *this;   
   //       retval.val *= r.val;
   //       return retval;
   //    }

   //    /// multiplication assignment operator
   //    Rational& operator*=(const Rational& r)
   //    {
   //       this->val *= r.val;
   //       return *this;
   //    }

   //    /// multiplication operator for doubles
   //    Rational operator*(const double& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val *= d;
   //       return retval;
   //    }

   //    /// multiplication assignment operator for doubles
   //    Rational& operator*=(const double& d)
   //    {
   //       this->val *= d;
   //       return *this;
   //    }

   //    /// multiplication operator for ints
   //    Rational operator*(const int& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val *= d;
   //       return retval;
   //    }

   //    /// multiplication assignment operator for ints
   //    Rational& operator*=(const int& d)
   //    {
   //       this->val *= d;
   //       return *this;
   //    }

   //    /// division operator
   //    Rational operator/(const Rational& r) const
   //    {
   //       Rational retval = *this;
   //       retval.val /= r.val;
   //       return retval;
   //    }

   //    /// division assignment operator
   //    Rational& operator/=(const Rational& r)
   //    {
   //       this->val /= r.val;
   //       return *this;
   //    }

   //    /// division operator for doubles
   //    Rational operator/(const double& d) const
   //    {
   //       Rational retval = *this;
   //       retval.val /= d;
   //       return retval;
   //    }

   //    /// division assignment operator for doubles
   //    Rational& operator/=(const double& d)
   //    {
   //       this->val /= d;
   //       return *this;
   //    }

   //    /// division operator for ints
   //    Rational operator/(const int& r) const
   //    {
   //       Rational retval = *this;
   //       retval.val /= r;
   //       return retval;
   //    }

   //    /// division assignment operator for ints
   //    Rational& operator/=(const int& r)
   //    {
   //       this->val /= r;
   //       return *this;
   //    }

   // };
   // inline Rational ratFromString(const char* str)
   // {
   //    Rational ret;
   //    if( sscanf(str, "%lf", &ret.val) != 1 )
   //       throw std::runtime_error("wrong formatted rational string\n");

   //    return ret;
   // }

   // inline std::string str(Rational r)
   // {
   //    std::string s = std::to_string(r.val);
   //    return s;
   // }

   // inline Integer numerator(const Rational& r)
   // {
   //    return (Integer) r.val;
   // }
   // inline Integer denominator(const Rational& r)
   // {
   //    return (Integer) r.val;
   // }

   // inline void SpxGcd(Integer restult, Integer a, Integer b)
   // {
   //    return;
   // }
   // inline void SpxLcm(Integer restult, Integer a, Integer b)
   // {
   //    return;
   // }
   // inline void divide_qr(Integer a, Integer b, Integer c, Integer d)
   // {
   //    return;
   // }
#endif

#endif